# Lab-02 åŸºäº RSA ç®—æ³•è‡ªåŠ¨åˆ†é…å¯†é’¥çš„åŠ å¯†èŠå¤©ç¨‹åº

<p align="center">
    <img src="https://img.shields.io/badge/License-MIT-blue" alt="License">
    <img src="https://img.shields.io/badge/Linux-âœ…-success" alt="Platform">
    <img src="https://img.shields.io/badge/MacOS-âœ…-success" alt="Platform">
    <img src="https://img.shields.io/badge/Windows-âœ…-success" alt="Platform">
</p>

> æ­¦æ¡è¥¿ 2112515 ä¿¡æ¯å®‰å…¨

## ä¸€ã€å®éªŒç›®çš„ä¸è¦æ±‚

æœ¬æ¬¡å®éªŒåœ¨ä¸Šæ¬¡çš„ DESåŠ å¯†çš„TCPèŠå¤©ç¨‹åº çš„åŸºç¡€ä¸Šè¿›è¡ŒäºŒæ¬¡å¼€å‘ï¼Œä½¿åŸæœ‰çš„ç¨‹åºå¯ä»¥å®ç°å…¨è‡ªåŠ¨ç”Ÿæˆ DES å¯†é’¥ä»¥åŠåŸºäº RSA ç®—æ³•çš„å¯†é’¥åˆ†é…ã€‚å…·ä½“è¦æ±‚å¦‚ä¸‹ï¼š

1. åŠ æ·±å¯¹ RSA ç®—æ³•ç­‰å…¬é’¥å¯†ç ä½“åˆ¶åŸºæœ¬å·¥ä½œåŸç†çš„ç†è§£ã€‚
2. æŒæ¡åŸºäº RSA ç®—æ³•çš„ä¿å¯†é€šä¿¡ç³»ç»Ÿçš„åŸºæœ¬è®¾è®¡æ–¹æ³•ã€‚
3. å®ŒæˆåŸºäº RSA ç®—æ³•çš„ä¿å¯†é€šä¿¡ç¨‹åºçš„ç¼–å†™ã€‚
4. ç¨‹åºå¿…é¡»åŒ…å« DES å¯†é’¥è‡ªåŠ¨ç”Ÿæˆã€RSA å¯†é’¥åˆ†é…ä»¥åŠ DES åŠ å¯†é€šè®¯ä¸‰ä¸ªéƒ¨åˆ†ã€‚
5. è¦æ±‚ç¨‹åºå®ç°å…¨åŒå·¥é€šä¿¡ï¼Œå¹¶ä¸”åŠ å¯†è¿‡ç¨‹å¯¹ç”¨æˆ·å®Œå…¨é€æ˜ã€‚

## äºŒã€å®éªŒåŸç†

### 2.1 RSA

RSAï¼ˆRivest-Shamir-Adlemanï¼‰æ˜¯ä¸€ç§**éå¯¹ç§°åŠ å¯†**ç®—æ³•ï¼Œå¹¿æ³›åº”ç”¨äºç½‘ç»œé€šä¿¡å’Œæ•°æ®å®‰å…¨é¢†åŸŸã€‚å®ƒåŸºäºå¤§æ•´æ•°åˆ†è§£è¿™ä¸€æ•°è®ºé—®é¢˜ï¼Œå…¶ä¸­åŒ…æ‹¬ä¸¤ä¸ªä¸»è¦æ­¥éª¤ï¼šå¯†é’¥ç”Ÿæˆå’ŒåŠ è§£å¯†è¿‡ç¨‹ã€‚

#### å¯†é’¥ç”Ÿæˆ

1. **é€‰æ‹©ç´ æ•°**ï¼šé€‰æ‹©ä¸¤ä¸ªå¤§ç´ æ•° $ p $ å’Œ $ q $ã€‚
2. **è®¡ç®— $ n $ å’Œ $ \phi(n) $**ï¼šè®¡ç®— $ n = p \times q $ï¼Œ $ \phi(n) = (p-1) \times (q-1) $ã€‚
3. **é€‰æ‹©å…¬é’¥ $ e $**ï¼šé€‰æ‹©ä¸€ä¸ªä¸ $ \phi(n) $ äº’è´¨ä¸” $ 1 < e < \phi(n) $ çš„æ•°ã€‚
4. **è®¡ç®—ç§é’¥ $ d $**ï¼šè®¡ç®— $ d $ï¼Œä½¿å¾— $ e \times d \equiv 1 \pmod{\phi(n)} $ï¼Œå³ $ e \times d = k \times \phi(n) + 1 $ çš„å½¢å¼ã€‚

ç”Ÿæˆçš„å…¬é’¥ $ (e, n) $ ç”¨äºåŠ å¯†ï¼Œç§é’¥ $ (d, n) $ ç”¨äºè§£å¯†ã€‚

#### åŠ å¯†è¿‡ç¨‹

1. **è½¬æ¢æ¶ˆæ¯**ï¼šå°†è¦åŠ å¯†çš„æ¶ˆæ¯ $ M $ è½¬æ¢ä¸ºæ•´æ•° $ m $ï¼Œç¡®ä¿ $ 0 \leq m < n $ã€‚
2. **åŠ å¯†**ï¼šè®¡ç®— $ C \equiv M^e \pmod{n} $ã€‚åŠ å¯†åçš„å¯†æ–‡ $ C $ ä¼ è¾“ç»™æ¥æ”¶è€…ã€‚

#### è§£å¯†è¿‡ç¨‹

1. **è§£å¯†**ï¼šæ¥æ”¶åˆ°å¯†æ–‡ $ C $ åï¼Œæ¥æ”¶è€…ä½¿ç”¨ç§é’¥ $ d $ è¿›è¡Œè§£å¯†ï¼š$ M \equiv C^d \pmod{n} $ã€‚
2. **è½¬æ¢å›æ¶ˆæ¯**ï¼šå°†è§£å¯†å¾—åˆ°çš„æ•´æ•° $ M $ è½¬æ¢å›æ¶ˆæ¯ $ m $ã€‚

RSAåŠ è§£å¯†è¿‡ç¨‹çš„å®‰å…¨æ€§åŸºäºå¤§æ•°åˆ†è§£é—®é¢˜çš„å›°éš¾æ€§ï¼Œå³ä» $ n $ ä¸­æ¢å¤å‡º $ p $ å’Œ $ q $ çš„éš¾åº¦ã€‚å› ä¸º $ n $ çš„é•¿åº¦é€šå¸¸ä¸ºå‡ ç™¾åˆ°å‡ åƒä½ï¼Œç›®å‰çš„è®¡ç®—èƒ½åŠ›æ— æ³•æœ‰æ•ˆåœ°åˆ†è§£å¤§çš„åˆæ•° $ n $ã€‚

#### åº”ç”¨

RSAç®—æ³•ä½œä¸ºä¸€ç§éå¯¹ç§°åŠ å¯†ç®—æ³•ï¼Œå…·æœ‰å¹¿æ³›çš„åº”ç”¨é¢†åŸŸï¼Œä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š

1. **åŠ å¯†é€šä¿¡**ï¼šRSAç®—æ³•å¸¸ç”¨äºä¿æŠ¤ç½‘ç»œé€šä¿¡çš„å®‰å…¨æ€§ï¼Œåœ¨åè®®ä¸­ä½¿ç”¨RSAç®—æ³•åŠ å¯†æ•°æ®ä¼ è¾“ï¼Œç¡®ä¿æ•°æ®åœ¨ä¼ è¾“è¿‡ç¨‹ä¸­ä¸è¢«çªƒå–æˆ–ç¯¡æ”¹ã€‚
2. **æ•°å­—ç­¾å**ï¼šRSAç®—æ³•ä¹Ÿå¸¸ç”¨äºæ•°å­—ç­¾åé¢†åŸŸï¼Œé€šè¿‡ç§é’¥å¯¹æ¶ˆæ¯è¿›è¡Œç­¾åï¼Œæ¥æ”¶è€…ä½¿ç”¨å…¬é’¥éªŒè¯ç­¾åçš„æœ‰æ•ˆæ€§ï¼Œç¡®ä¿æ¶ˆæ¯çš„å®Œæ•´æ€§å’Œæ¥æºå¯ä¿¡ã€‚
3. **èº«ä»½è®¤è¯**ï¼šRSAç®—æ³•å¯ä»¥ç”¨äºèº«ä»½è®¤è¯æœºåˆ¶ï¼Œå¦‚åœ¨æ•°å­—è¯ä¹¦ä¸­ä½¿ç”¨RSAç®—æ³•å¯¹è¯ä¹¦è¿›è¡Œç­¾åï¼ŒéªŒè¯è¯ä¹¦çš„çœŸå®æ€§å’Œåˆæ³•æ€§ï¼Œç¡®ä¿é€šä¿¡åŒæ–¹çš„èº«ä»½æ˜¯å¯ä¿¡çš„ã€‚
4. **è®¿é—®æ§åˆ¶**ï¼šåœ¨ç³»ç»Ÿå®‰å…¨é¢†åŸŸï¼ŒRSAç®—æ³•å¯ä»¥ç”¨äºè®¿é—®æ§åˆ¶æœºåˆ¶ï¼Œå¦‚åŠ å¯†å­˜å‚¨è®¿é—®æ§åˆ¶åˆ—è¡¨ï¼ˆACLï¼‰ï¼Œç¡®ä¿åªæœ‰æˆæƒç”¨æˆ·èƒ½å¤Ÿè®¿é—®å—ä¿æŠ¤çš„èµ„æºã€‚
5. **æ”¯ä»˜å®‰å…¨**ï¼šåœ¨çº¿æ”¯ä»˜ç³»ç»Ÿå¸¸ä½¿ç”¨RSAç®—æ³•è¿›è¡Œæ”¯ä»˜ä¿¡æ¯çš„åŠ å¯†å’Œæ•°å­—ç­¾åï¼Œä¿æŠ¤ç”¨æˆ·çš„æ”¯ä»˜æ•°æ®ä¸è¢«æ¶æ„æ”»å‡»è€…è·å–æˆ–ç¯¡æ”¹ã€‚
6. **æ•°æ®åŠ å¯†**ï¼šé™¤äº†é€šä¿¡å¤–ï¼ŒRSAç®—æ³•ä¹Ÿå¯ç”¨äºå¯¹æœ¬åœ°æ•°æ®è¿›è¡ŒåŠ å¯†å­˜å‚¨ï¼Œå¦‚åŠ å¯†æ–‡ä»¶ã€åŠ å¯†æ•°æ®åº“ç­‰ï¼Œä¿æŠ¤æ•°æ®åœ¨å­˜å‚¨å’Œä¼ è¾“è¿‡ç¨‹ä¸­çš„å®‰å…¨æ€§ã€‚

æ€»ä½“è€Œè¨€ï¼ŒRSAç®—æ³•åœ¨ä¿¡æ¯å®‰å…¨é¢†åŸŸå‘æŒ¥ç€é‡è¦ä½œç”¨ï¼Œä¸ºä¿æŠ¤æ•°æ®çš„å®‰å…¨æ€§ã€å®Œæ•´æ€§å’Œå¯ä¿¡æ€§æä¾›äº†æœ‰æ•ˆçš„åŠ å¯†å’Œè®¤è¯æ‰‹æ®µã€‚

### 2.2 DES

DESï¼ˆData Encryption Standardï¼‰æ˜¯ä¸€ç§å¯¹ç§°åŠ å¯†ç®—æ³•ï¼Œè®¾è®¡äºä¸Šä¸–çºª70å¹´ä»£åˆï¼Œæ˜¯æœ€æ—©çš„å•†ä¸šåŠ å¯†æ ‡å‡†ä¹‹ä¸€ã€‚è™½ç„¶ç°åœ¨å·²ç»è¢«æ›´å®‰å…¨çš„ç®—æ³•å–ä»£ï¼Œä½†å®ƒçš„åŸºæœ¬å·¥ä½œåŸç†ä»å…·æœ‰æ•™è‚²æ„ä¹‰ã€‚

#### DESçš„åŸºæœ¬ç»“æ„å’Œå‚æ•°ï¼š

- **æ•°æ®å—å¤§å°**ï¼šDESä»¥64ä½çš„æ•°æ®å—ä¸ºå•ä½è¿›è¡ŒåŠ å¯†å’Œè§£å¯†ã€‚
- **å¯†é’¥é•¿åº¦**ï¼šDESå¯†é’¥é•¿åº¦ä¸º56ä½ï¼Œä½†å®é™…ä½¿ç”¨ä¸­æ˜¯64ä½ï¼Œå…¶ä¸­8ä½ç”¨äºå¥‡å¶æ ¡éªŒã€‚
- **è½®æ•°**ï¼šDESä½¿ç”¨16è½®è¿­ä»£çš„Feistelç»“æ„è¿›è¡ŒåŠ å¯†æˆ–è§£å¯†ã€‚

#### DESçš„åŠ å¯†æµç¨‹ï¼š

1. **å¯†é’¥ç”Ÿæˆ**ï¼š
   - å°†56ä½çš„å¯†é’¥æ‰©å±•ä¸º64ä½ï¼Œå¹¶æ ¹æ®å¥‡å¶æ ¡éªŒä½ç”Ÿæˆ64ä½çš„åˆå§‹å¯†é’¥ã€‚
   - å°†åˆå§‹å¯†é’¥åˆ†ä¸ºå·¦å³å„32ä½ï¼Œå½¢æˆå·¦å³ä¸¤ä¸ªå­å¯†é’¥ã€‚
   - ä¹‹åè¿›è¡Œ16è½®å­å¯†é’¥ç”Ÿæˆï¼Œç”Ÿæˆ16ä¸ªè½®å¯†é’¥ã€‚

2. **åˆå§‹ç½®æ¢ï¼ˆIPç½®æ¢ï¼‰**ï¼š
   - å°†64ä½æ˜æ–‡æ ¹æ®å›ºå®šçš„IPç½®æ¢è¡¨è¿›è¡Œç½®æ¢ï¼Œå¾—åˆ°L0å’ŒR0ï¼ˆå„32ä½ï¼‰ã€‚

3. **è¿­ä»£è¿‡ç¨‹**ï¼š
   - ä»ç¬¬1è½®åˆ°ç¬¬16è½®ï¼Œæ¯è½®çš„æ“ä½œå¦‚ä¸‹ï¼š
     1. å°†å³åŠéƒ¨åˆ†Rnä½œä¸ºè½®å‡½æ•°çš„è¾“å…¥ï¼Œä¸è¯¥è½®çš„å­å¯†é’¥Knè¿›è¡Œæ··åˆï¼ˆè½®å¯†é’¥ç”Ÿæˆï¼‰ã€‚
     2. ç»è¿‡è½®å‡½æ•°ï¼ˆåŒ…æ‹¬æ‰©å±•ã€ç½®æ¢ã€æ›¿æ¢ç­‰æ“ä½œï¼‰ï¼Œè¾“å‡º32ä½ç»“æœFã€‚
     3. å°†Lnä¸Fè¿›è¡Œå¼‚æˆ–æ“ä½œï¼Œå¾—åˆ°Rn+1ï¼›Rn+1ä¸Lnç›¸ç­‰ï¼ŒLn+1ç­‰äºRnã€‚

4. **é€†åˆå§‹ç½®æ¢ï¼ˆIP-1ç½®æ¢ï¼‰**ï¼š
   - å°†ç»è¿‡16è½®è¿­ä»£çš„R16å’ŒL16æŒ‰ç…§IP-1ç½®æ¢è¡¨è¿›è¡Œé€†ç½®æ¢ï¼Œå¾—åˆ°åŠ å¯†åçš„64ä½å¯†æ–‡ã€‚

#### DESçš„è§£å¯†æµç¨‹ï¼š

1. **å¯†é’¥ç”Ÿæˆ**ï¼šä¸åŠ å¯†è¿‡ç¨‹ç›¸åŒï¼Œç”Ÿæˆ16è½®çš„å­å¯†é’¥ã€‚

2. **åˆå§‹ç½®æ¢ï¼ˆIPç½®æ¢ï¼‰**ï¼šä¸åŠ å¯†è¿‡ç¨‹ç›¸åŒï¼Œå°†64ä½å¯†æ–‡è¿›è¡ŒIPç½®æ¢ï¼Œå¾—åˆ°L0å’ŒR0ã€‚

3. **è¿­ä»£è¿‡ç¨‹**ï¼šä¸åŠ å¯†è¿‡ç¨‹ç›¸åŒï¼Œä½†è½®å¯†é’¥çš„åº”ç”¨é¡ºåºä¸åŠ å¯†è¿‡ç¨‹ç›¸åï¼Œä»K16åˆ°K1ã€‚

4. **é€†åˆå§‹ç½®æ¢ï¼ˆIP-1ç½®æ¢ï¼‰**ï¼šä¸åŠ å¯†è¿‡ç¨‹ç›¸åŒï¼Œå°†ç»è¿‡16è½®è¿­ä»£çš„R16å’ŒL16æŒ‰ç…§IP-1ç½®æ¢è¡¨è¿›è¡Œé€†ç½®æ¢ï¼Œå¾—åˆ°è§£å¯†åçš„64ä½æ˜æ–‡ã€‚

#### åŠ å¯†å’Œè§£å¯†è¿‡ç¨‹çš„å…³é”®ç‚¹ï¼š

- **è½®å‡½æ•°ï¼ˆFå‡½æ•°ï¼‰**ï¼šåŒ…æ‹¬æ•°æ®æ‰©å±•ã€Sç›’æ›¿æ¢ã€Pç›’ç½®æ¢ç­‰æ“ä½œï¼Œç”¨äºæ··æ·†æ•°æ®å’Œå¢åŠ å¯†æ–‡çš„å¤æ‚æ€§ã€‚
- **å¯†é’¥æ‰©å±•**ï¼šæ ¹æ®åˆå§‹å¯†é’¥ç”Ÿæˆ16è½®çš„è½®å¯†é’¥ï¼Œç”¨äºè½®å‡½æ•°ä¸­çš„å¯†é’¥æ··åˆæ“ä½œã€‚
- **IPå’ŒIP-1ç½®æ¢**ï¼šç”¨äºæ‰“ä¹±æ•°æ®çš„ä½é¡ºåºï¼Œå¢åŠ åŠ å¯†å’Œè§£å¯†çš„éš¾åº¦ã€‚

æ€»çš„æ¥è¯´ï¼ŒDESçš„åŠ å¯†å’Œè§£å¯†è¿‡ç¨‹éƒ½æ˜¯é€šè¿‡å¤šè½®è¿­ä»£å’Œæ··åˆæ“ä½œæ¥å®ç°çš„ï¼Œå…¶ä¸­å¯†é’¥çš„ç”Ÿæˆå’Œè½®å¯†é’¥çš„åº”ç”¨æ˜¯å…³é”®æ­¥éª¤ã€‚ç”±äºç°ä»£è®¡ç®—èƒ½åŠ›çš„æé«˜å’Œå¯†ç åˆ†ææŠ€æœ¯çš„å‘å±•ï¼ŒDESå·²ç»ä¸å†å®‰å…¨ï¼Œé€šå¸¸ä¸å»ºè®®åœ¨å®é™…åº”ç”¨ä¸­ä½¿ç”¨ï¼Œè€Œåº”é€‰æ‹©æ›´å®‰å…¨çš„ç®—æ³•å¦‚AESæ¥ä¿æŠ¤æ•°æ®çš„å®‰å…¨æ€§ã€‚

### 2.3 TCP

TCPï¼ˆTransmission Control Protocolï¼‰æ˜¯ä¸€ç§é¢å‘è¿æ¥çš„ã€å¯é çš„ä¼ è¾“å±‚åè®®ï¼Œå®ƒåœ¨äº’è”ç½‘åè®®å¥—ä»¶ä¸­è´Ÿè´£æ•°æ®çš„å¯é ä¼ è¾“ã€‚ä¸‹é¢è¯¦ç»†ä»‹ç»TCPåè®®çš„åŸç†ä»¥åŠå…¶ä¼˜ç¼ºç‚¹ã€‚

#### TCPåè®®çš„åŸç†ï¼š

1. **é¢å‘è¿æ¥**ï¼šTCPæ˜¯é¢å‘è¿æ¥çš„åè®®ï¼Œé€šä¿¡åŒæ–¹éœ€è¦åœ¨ä¼ è¾“æ•°æ®ä¹‹å‰å»ºç«‹è¿æ¥ï¼Œç„¶åè¿›è¡Œæ•°æ®ä¼ è¾“ï¼Œæœ€åå†é‡Šæ”¾è¿æ¥ã€‚

2. **å¯é æ€§**ï¼šTCPæä¾›å¯é çš„æ•°æ®ä¼ è¾“ï¼Œé€šè¿‡åºå·ã€ç¡®è®¤å’Œé‡ä¼ æœºåˆ¶ç¡®ä¿æ•°æ®çš„å¯é æ€§ã€‚æ¯ä¸ªæ•°æ®åŒ…éƒ½æœ‰ä¸€ä¸ªåºå·ï¼Œæ¥æ”¶æ–¹ä¼šå‘é€ç¡®è®¤ä¿¡æ¯ï¼Œå‘é€æ–¹å¦‚æœæœªæ”¶åˆ°ç¡®è®¤ï¼Œåˆ™ä¼šé‡ä¼ æ•°æ®ã€‚

3. **æµé‡æ§åˆ¶**ï¼šTCPä½¿ç”¨æ»‘åŠ¨çª—å£åè®®æ¥è¿›è¡Œæµé‡æ§åˆ¶ï¼Œå³æ¥æ”¶æ–¹ä¼šå‘ŠçŸ¥å‘é€æ–¹è‡ªå·±çš„æ¥æ”¶çª—å£å¤§å°ï¼Œå‘é€æ–¹æ ¹æ®çª—å£å¤§å°è°ƒæ•´å‘é€é€Ÿç‡ï¼Œä»¥é¿å…å‘é€è¿‡å¤šæ•°æ®å¯¼è‡´ç½‘ç»œæ‹¥å¡ã€‚

4. **æ‹¥å¡æ§åˆ¶**ï¼šTCPçš„æ‹¥å¡æ§åˆ¶æœºåˆ¶é€šè¿‡æ…¢å¯åŠ¨ã€æ‹¥å¡é¿å…å’Œå¿«é€Ÿé‡ä¼ ç­‰ç®—æ³•æ¥é¿å…ç½‘ç»œæ‹¥å¡å’Œæ•°æ®ä¸¢å¤±ã€‚

5. **åˆ†æ®µå’Œé‡ç»„**ï¼šTCPä¼šå°†æ•°æ®åˆ†æˆå¤šä¸ªæŠ¥æ–‡æ®µè¿›è¡Œä¼ è¾“ï¼Œå¹¶åœ¨æ¥æ”¶ç«¯è¿›è¡Œé‡ç»„ï¼Œä¿è¯æ•°æ®çš„å®Œæ•´æ€§å’Œæ­£ç¡®æ€§ã€‚

6. **è¶…æ—¶é‡ä¼ **ï¼šå¦‚æœå‘é€æ–¹åœ¨ä¸€å®šæ—¶é—´å†…æœªæ”¶åˆ°ç¡®è®¤ä¿¡æ¯ï¼Œåˆ™ä¼šè®¤ä¸ºæ•°æ®ä¸¢å¤±ï¼Œè§¦å‘è¶…æ—¶é‡ä¼ æœºåˆ¶ã€‚

#### TCPåè®®çš„ä¼˜ç‚¹ï¼š

1. **å¯é æ€§**ï¼šTCPæä¾›å¯é çš„æ•°æ®ä¼ è¾“ï¼Œä¿è¯æ•°æ®çš„å®Œæ•´æ€§å’Œæ­£ç¡®æ€§ã€‚
2. **æµé‡æ§åˆ¶**ï¼šé€šè¿‡æ»‘åŠ¨çª—å£åè®®è¿›è¡Œæµé‡æ§åˆ¶ï¼Œé¿å…å‘é€è¿‡å¤šæ•°æ®å¯¼è‡´ç½‘ç»œæ‹¥å¡ã€‚
3. **æ‹¥å¡æ§åˆ¶**ï¼šTCPçš„æ‹¥å¡æ§åˆ¶æœºåˆ¶èƒ½å¤Ÿæœ‰æ•ˆé¿å…ç½‘ç»œæ‹¥å¡ï¼Œä¿è¯ç½‘ç»œçš„ç¨³å®šæ€§ã€‚
4. **é¡ºåºä¼ è¾“**ï¼šTCPä¿è¯æ•°æ®æŒ‰é¡ºåºä¼ è¾“ï¼Œæ¥æ”¶æ–¹å¯ä»¥æ­£ç¡®é‡ç»„æ•°æ®ã€‚
5. **é€‚ç”¨èŒƒå›´å¹¿**ï¼šTCPå¹¿æ³›åº”ç”¨äºå¯é ä¼ è¾“è¦æ±‚è¾ƒé«˜çš„åœºæ™¯ï¼Œå¦‚ç½‘é¡µæµè§ˆã€æ–‡ä»¶ä¼ è¾“ã€ç”µå­é‚®ä»¶ç­‰ã€‚

#### TCPåè®®çš„ç¼ºç‚¹ï¼š

1. **å¼€é”€å¤§**ï¼šTCPçš„å¯é æ€§å’Œæµé‡æ§åˆ¶æœºåˆ¶ä¼šå¢åŠ é¢å¤–çš„å¼€é”€ï¼Œå¯¼è‡´ä¼ è¾“æ•ˆç‡ç›¸å¯¹è¾ƒä½ã€‚
2. **å»¶è¿Ÿè¾ƒé«˜**ï¼šç”±äºéœ€è¦å»ºç«‹è¿æ¥ã€ç¡®è®¤æ•°æ®å’Œé‡ä¼ æœºåˆ¶ï¼ŒTCPçš„å»¶è¿Ÿæ¯”UDPç­‰åè®®è¾ƒé«˜ã€‚
3. **ä¸é€‚ç”¨äºå®æ—¶æ€§è¦æ±‚é«˜çš„åº”ç”¨**ï¼šç”±äºå»¶è¿Ÿè¾ƒé«˜å’Œå¼€é”€è¾ƒå¤§ï¼ŒTCPä¸é€‚åˆå®æ—¶æ€§è¦æ±‚è¾ƒé«˜çš„åº”ç”¨ï¼Œå¦‚è§†é¢‘æµã€åœ¨çº¿æ¸¸æˆç­‰ã€‚

æ€»çš„æ¥è¯´ï¼ŒTCPåè®®åœ¨ä¿è¯æ•°æ®å¯é ä¼ è¾“æ–¹é¢è¡¨ç°ä¼˜ç§€ï¼Œä½†åœ¨ä¼ è¾“æ•ˆç‡å’Œå®æ—¶æ€§æ–¹é¢å­˜åœ¨ä¸€å®šçš„ç¼ºé™·ï¼Œå› æ­¤åœ¨è®¾è®¡ç½‘ç»œåº”ç”¨æ—¶éœ€è¦æ ¹æ®å…·ä½“éœ€æ±‚é€‰æ‹©åˆé€‚çš„ä¼ è¾“åè®®ã€‚

## ä¸‰ã€å®éªŒå¹³å°ä¸è¿è¡Œè¯´æ˜

### :tada: Multi-Platform

æœ¬æ¬¡å®éªŒåˆ©ç”¨**æ¡ä»¶ç¼–è¯‘**å®ç°äº†**è·¨å¹³å°**ï¼Œæ”¯æŒ Linuxå¹³å°ã€MacOSå¹³å°ä»¥åŠ WIndowså¹³å°ç­‰ã€‚

å¯ä»¥ä½¿ç”¨ `CMake` è¿›è¡Œæ„å»ºã€‚

> å®éªŒä»£ç å·²åœ¨ [GitHub](https://github.com/InfinityUniverse0/Network-Security-2024) ä¸Šä¼ ï¼Œè®¡åˆ’äºå­¦æœŸç»“æŸåå¼€æºã€‚

#### Quick Start

You can run this chat program on Linux:penguin:, MacOS:apple: and Windows:checkered_flag: .

**Prerequisite**: Please make sure that you have installed `CMake` on your machine. If not, you need to install `CMake` first.

When you are in the same directory with this `README` file, run the below command in your terminal (bash, zsh, command line, or powershell):

```sh
cmake . -B build && cmake --build build
```

Then, run the below command to execute the chat program:

```sh
cd bin
./EncChat
```

You may choose it as server or client by inputting `s` or `c` respectively.

> [!NOTE]
>
> **NOTE** that this program now only support chat between one client and one server.

> [!WARNING]
>
> In Windows Platform, MSVC does **NOT** suggest 128-bit integer. You can use MinGW-w64 instead.

### æ–‡ä»¶ç»“æ„

æœ¬æ¬¡å®éªŒçš„æ–‡ä»¶ç»“æ„å¦‚ä¸‹ï¼š

```sh
.
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ bin
â”‚Â Â  â””â”€â”€ EncChat // Excutable
â”œâ”€â”€ include
â”‚Â Â  â”œâ”€â”€ DesOp.h
â”‚Â Â  â”œâ”€â”€ RSA.h
â”‚Â Â  â””â”€â”€ chat.h
â”œâ”€â”€ main.cpp
â””â”€â”€ src
    â”œâ”€â”€ DesOp.cpp
    â”œâ”€â”€ RSA.cpp
    â””â”€â”€ chat.cpp
```

ä½ å¯ä»¥ä½¿ç”¨ `CMake` è¿›è¡Œæ„å»ºï¼Œä»è€Œè¿›è¡Œç¼–è¯‘å¹¶ç”Ÿæˆä½ å¯¹åº”çš„å¹³å°çš„å¯æ‰§è¡Œæ–‡ä»¶ `EncChat` ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç¬”è€…çš„èŠå¤©ç¨‹åºçš„å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ç«¯å‡é›†æˆåœ¨ `Chat` ç±»ä¸­ï¼Œä½¿ç”¨æ—¶ä¾æ®å‘½ä»¤è¡Œçš„è¾“å…¥ `s/c` æ¥å†³å®šå½“å‰ç¨‹åºè¿è¡Œçš„æ˜¯å®¢æˆ·ç«¯è¿˜æ˜¯æœåŠ¡å™¨ç«¯ã€‚

![image-20240421221422320](./README.assets/image-20240421221422320.png)

## å››ã€å®éªŒè¿‡ç¨‹

æœ¬æ¬¡å®éªŒä¸­åœ¨ä¸Šä¸€æ¬¡å®éªŒçš„åŸºç¡€ä¸Šè¿›è¡ŒäºŒæ¬¡å¼€å‘ï¼Œ**å¢åŠ **çš„å†…å®¹ä¸»è¦æœ‰ï¼š

1. RSAç®—æ³•éƒ¨åˆ†ï¼Œå®ç°RSAçš„å¯†é’¥ç”Ÿæˆä»¥åŠåŠ å¯†ä¸è§£å¯†ï¼›
2. åŸºäºRSAå®ç°DESå¯¹ç§°åŠ å¯†å¯†é’¥çš„å®‰å…¨äº¤æ¢ã€‚

å› æ­¤ï¼Œæœ¬æ¬¡å®éªŒä¸»è¦ä»‹ç»ä¸Šé¢çš„æ–°å¢éƒ¨åˆ†ã€‚

### RSAå…¬é’¥å¯†ç ä½“åˆ¶

å°†RSAå…¬é’¥å¯†ç ä½“åˆ¶å°è£…ä¸ºç±»ï¼Œå¦‚ä¸‹ï¼š

```c++
class RSA {
private:
    uint64_t p; // Prime number p
    uint64_t q; // Prime number q
    uint64_t n; // n = p * q
    uint64_t phi; // Euler's totient function
    uint64_t e; // Public key e
    uint64_t d; // Private key d

    static uint64_t ModExp(uint64_t base, uint64_t exp, uint64_t mod); // Modular exponentiation
    static uint64_t ModInv(uint64_t a, uint64_t m); // Modular inverse
    static bool MillerRabin(uint64_t n, int round = 50); // Miller-Rabin primality test

public:
    RSA();
    ~RSA();
    bool GenerateKey(); // Generate public and private keys
    inline uint64_t GetPublicKey() {return e;}; // Get public key
    inline uint64_t GetModulus() {return n;}; // Get modulus
    static uint64_t Encrypt(uint32_t plainText, uint64_t e, uint64_t n); // Encrypt
    uint32_t Decrypt(uint64_t cipherText); // Decrypt
};
```

å…¶ä¸­ï¼ŒRSAä½“åˆ¶ä¸»è¦çš„å‚æ•°æœ‰ï¼š

1. `p` `q` ï¼šå‡ä¸ºå¤§ç´ æ•°ï¼›
2.  `n` ï¼š$n = p \times q$ ï¼›
3. `phi` ï¼š$\varphi(n) = (p-1) \times (q-1)$ ï¼›
4. `e` ï¼š$ \gcd(e, \varphi(n)) = 1, \, 1 < e < \varphi(n) $ ï¼›
5. `d` ï¼š$ d \equiv e^{-1} \mod \varphi(n) $ å³ $ e \cdot d \equiv 1 \mod \varphi(n) $ ã€‚

åœ¨RSAä¸­ï¼Œå…³é”®çš„æ“ä½œä¸»è¦æœ‰ï¼š

1. **æ¨¡å¹‚è¿ç®—**ï¼šä½¿ç”¨ **å¹³æ–¹-ä¹˜** ç®—æ³•è¿›è¡Œå¿«é€Ÿæ¨¡å¹‚è¿ç®—ã€‚
2. **ä¹˜æ³•é€†å…ƒ**ï¼šåˆ©ç”¨æ‰©å±•çš„æ¬§å‡ é‡Œå¾—ç®—æ³•å®ç°æ±‚ä¹˜æ³•é€†å…ƒã€‚
3. **ç´ æ€§æ£€æµ‹**ï¼šé‡‡ç”¨ Miller-Rabin ç®—æ³•è¿›è¡Œç´ æ€§æ£€æµ‹ï¼ˆæ¦‚ç‡æ€§ç®—æ³•ï¼‰ã€‚

> âš ï¸ æ³¨æ„
>
> æœ¬æ¬¡å®éªŒä¸­ï¼Œä¸ºäº†æ¼”ç¤ºä»¥åŠä¾¿äºç¼–ç¨‹å®ç°ï¼Œå°†RSAç®—æ³•çš„å¯†é’¥é•¿åº¦è®¾ç½®ä¸º 64 ä½ï¼Œè€Œä¸æ˜¯ä»å®‰å…¨æ€§è§’åº¦å‡ºå‘ä½¿ç”¨å¸¸ç”¨ä¸”è¾ƒä¸ºå®‰å…¨çš„ 2048 ä½ç­‰ã€‚
>
> åœ¨ä»£ç å®ç°è¿‡ç¨‹ä¸­ï¼Œä¸ºäº†è§£å†³æº¢å‡ºé—®é¢˜ï¼Œåœ¨è¿‡ç¨‹ä¸­æœ‰äº›åœ°æ–¹é‡‡ç”¨äº† 128 ä½æ•´æ•°ï¼Œè¿™ä¸åŒ…å«åœ¨C++æ ‡å‡†ä¸­ï¼Œä½†æ˜¯è®¸å¤šå¸¸è§çš„ç¼–è¯‘å™¨å‡æ”¯æŒï¼Œå¦‚G++ã€Clangç­‰ã€‚
>
> è‹¥è¦å®ç° 2048 ä½å¯†é’¥çš„RSAç®—æ³•ï¼Œéœ€è¦ç”¨åˆ°ç¬¬ä¸‰æ–¹çš„å¤§æ•´æ•°è¿ç®—åº“ï¼Œæ¯”å¦‚ GMP åº“ç­‰ï¼ˆéœ€è¦é¢å¤–ä¸‹è½½ï¼‰ã€‚

#### æ¨¡å¹‚è¿ç®—

**å¹³æ–¹-ä¹˜ç®—æ³•**ï¼ˆSquare-and-Multiply Algorithmï¼‰æ˜¯ä¸€ç§ç”¨äºå¿«é€Ÿè®¡ç®—å¤§æ•°çš„å¹‚çš„ç®—æ³•ï¼Œç‰¹åˆ«é€‚ç”¨äºæ¨¡æŒ‡æ•°è¿ç®—ï¼Œå¦‚ $ a^b \mod{n} $ çš„è®¡ç®—ï¼Œå…¶ä¸­ $ a $ å’Œ $ b $ éƒ½æ˜¯å¤§æ•´æ•°ï¼Œè€Œä¸” $ n $ ä¹Ÿæ˜¯ä¸€ä¸ªè¾ƒå¤§çš„æ•°ã€‚å…¶åŸºæœ¬æ€æƒ³æ˜¯åˆ©ç”¨äºŒè¿›åˆ¶å½¢å¼çš„æŒ‡æ•° $ b $ æ¥åŠ é€Ÿå¹‚è¿ç®—çš„è®¡ç®—è¿‡ç¨‹ã€‚

##### å¹³æ–¹-ä¹˜ç®—æ³•çš„æ­¥éª¤

1. **å°†æŒ‡æ•° $ b $ è½¬æ¢ä¸ºäºŒè¿›åˆ¶å½¢å¼**ï¼šå°†æŒ‡æ•° $ b $ è¡¨ç¤ºä¸ºäºŒè¿›åˆ¶å½¢å¼ï¼Œä¾‹å¦‚ $ b = (b_{k-1}b_{k-2}...b_1b_0)_2 $ã€‚
2. **åˆå§‹åŒ–**ï¼šå°†ç»“æœ $ result $ åˆå§‹åŒ–ä¸º 1ï¼Œè®¾ç½® $ x = a $ã€‚
3. **ä»é«˜ä½åˆ°ä½ä½éå†äºŒè¿›åˆ¶æŒ‡æ•° $ b $**ï¼š
   - è‹¥ $ b_i = 1 $ï¼Œåˆ™å°† $ result $ ä¹˜ä»¥ $ x $ å¹¶å–æ¨¡ $ n $ï¼Œå³ $ result = (result \times x) \mod{n} $ã€‚
   - å°† $ x $ å¹³æ–¹å¹¶å–æ¨¡ $ n $ï¼Œå³ $ x = (x^2) \mod{n} $ã€‚
4. **é‡å¤æ­¥éª¤ 3 ç›´åˆ°éå†å®Œæ•´ä¸ªäºŒè¿›åˆ¶æŒ‡æ•° $ b $ **ã€‚

##### å¹³æ–¹-ä¹˜ç®—æ³•çš„æ€æƒ³

- **äºŒè¿›åˆ¶å½¢å¼çš„æŒ‡æ•°åŒ–ç®€è®¡ç®—**ï¼šé€šè¿‡å°†æŒ‡æ•° $ b $ è½¬æ¢ä¸ºäºŒè¿›åˆ¶å½¢å¼ï¼Œå¯ä»¥å°†æŒ‡æ•°åŒ–ç®€ä¸ºä¸€ç³»åˆ—å¹³æ–¹å’Œä¹˜æ³•æ“ä½œï¼Œä»è€Œå‡å°‘äº†ä¹˜æ³•çš„æ¬¡æ•°ï¼Œæé«˜äº†è®¡ç®—æ•ˆç‡ã€‚
- **å¹³æ–¹æ“ä½œçš„åˆ©ç”¨**ï¼šé€šè¿‡å¹³æ–¹æ“ä½œ $ x = (x^2) \mod{n} $ å¯ä»¥å¿«é€Ÿå¾—åˆ° $ x $ çš„å¹³æ–¹ï¼Œé¿å…äº†å¤šæ¬¡ä¹˜æ³•è¿ç®—çš„å¼€é”€ã€‚
- **æ¨¡è¿ç®—çš„ä¼˜åŒ–**ï¼šåœ¨æ¯ä¸€æ­¥çš„ä¹˜æ³•æ“ä½œåéƒ½è¿›è¡Œå–æ¨¡ $ n $ çš„è¿ç®—ï¼Œä¿è¯ç»“æœåœ¨è¾ƒå°èŒƒå›´å†…ï¼Œé¿å…äº†æº¢å‡ºé—®é¢˜å’Œå¤§æ•°è¿ç®—çš„å¤æ‚æ€§ã€‚

å¹³æ–¹-ä¹˜ç®—æ³•åœ¨è®¡ç®—å¤§æ•°çš„å¹‚æ—¶å…·æœ‰è¾ƒé«˜çš„æ•ˆç‡å’Œå¯é æ€§ï¼Œç‰¹åˆ«é€‚ç”¨äºå¯†ç å­¦ä¸­çš„åŠ å¯†ç®—æ³•å’Œæ•°å­—ç­¾åç­‰åœºæ™¯ä¸­å¯¹å¤§æ•°çš„å¿«é€Ÿè¿ç®—è¦æ±‚ã€‚

é‡‡ç”¨ **å¹³æ–¹-ä¹˜** ç®—æ³•è¿›è¡Œå¿«é€Ÿæ¨¡å¹‚è¿ç®—ï¼Œå…¶ä»£ç å¦‚ä¸‹ï¼š

```c++
uint64_t RSA::ModExp(uint64_t base, uint64_t exp, uint64_t mod) {
    // Use the square-and-multiply algorithm
    base = base % mod;
    uint64_t idx = (1LL << 63);
    while (!(exp & idx)) {
        idx >>= 1;
    }

    uint128_t result = 1; // In case of overflow
    while (idx) {
        result = (uint128_t)((result * result) % mod);
        if (exp & idx) {
            result = (uint128_t)((result * base) % mod);
        }
        idx >>= 1;
    }

    return (uint64_t)result;
}
```

âš ï¸ **æ³¨æ„**ï¼šåœ¨ä¸­é—´ç»“æœä¸­ï¼Œé‡‡ç”¨äº† 128 ä½çš„æ— ç¬¦å·æ•´æ•°ï¼Œä»¥é˜²æ­¢å‡ºç°ç›Šå¤„é—®é¢˜ã€‚

> 128ä½æ•´æ•°ä¸åŒ…å«åœ¨C++æ ‡å‡†ä¸­ï¼Œä½†æ˜¯è®¸å¤šå¸¸è§çš„ç¼–è¯‘å™¨å‡æ”¯æŒï¼Œå¦‚G++ã€Clangç­‰ã€‚æ­¤åä¸å†èµ˜è¿°ã€‚

#### ä¹˜æ³•é€†å…ƒ

ç”±äº $e$ ä¸ $d$ äº’ä¸ºä¹˜æ³•é€†å…ƒï¼Œå³ $ e \cdot d \equiv 1 \mod \varphi(n) $ ï¼Œå› æ­¤æ ¹æ® $e$ æ±‚ $d$ å³ä¸ºæ±‚ $e$ æ¨¡ $\varphi(n)$ çš„ä¹˜æ³•é€†å…ƒ $ d \equiv e^{-1} \mod \varphi(n) $ ã€‚

**æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•**ï¼ˆExtended Euclidean Algorithmï¼‰æ˜¯ä¸€ç§ç”¨äºæ±‚è§£ä¸¤ä¸ªæ•´æ•° $ a $ å’Œ $ b $ çš„æœ€å¤§å…¬çº¦æ•°ï¼ˆæœ€å¤§å…¬å› æ•°ï¼‰ä»¥åŠæ±‚è§£è´ç¥–ç­‰å¼ $ ax + by = \gcd(a, b) $ ä¸­ $ x $ å’Œ $ y $ çš„æ•´æ•°è§£çš„ç®—æ³•ã€‚å®ƒæ˜¯æ¬§å‡ é‡Œå¾—ç®—æ³•çš„æ‰©å±•å½¢å¼ï¼Œä¸»è¦ç”¨äºè§£å†³çº¿æ€§åŒä½™æ–¹ç¨‹ã€æ¨¡é€†å…ƒç­‰é—®é¢˜ã€‚

##### æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•çš„æ­¥éª¤

1. **åˆå§‹åŒ–**ï¼šå°† $ a $ å’Œ $ b $ åˆå§‹åŒ–ä¸ºè¾“å…¥çš„ä¸¤ä¸ªæ•´æ•°ï¼Œè®¾ç½® $ x_1 = 1, y_1 = 0, x_2 = 0, y_2 = 1 $ã€‚
2. **è¿­ä»£è®¡ç®—**ï¼šé‡å¤ä»¥ä¸‹æ­¥éª¤ç›´åˆ° $ b $ ä¸º 0ï¼š
   - è®¡ç®—å•† $ q $ å’Œä½™æ•° $ r $ï¼š$ q = \lfloor a / b \rfloor, r = a \mod b $ã€‚
   - æ›´æ–° $ a $ å’Œ $ b $ çš„å€¼ï¼š$ a = b, b = r $ã€‚
   - æ›´æ–° $ x_1, y_1, x_2, y_2 $ çš„å€¼ï¼š$ x_1 = x_2, y_1 = y_2, x_2 = x_1 - q \times x_2, y_2 = y_1 - q \times y_2 $ã€‚
3. **è¾“å‡ºç»“æœ**ï¼šå½“ $ b $ å˜ä¸º 0 æ—¶ï¼Œ$ a $ å³ä¸º $ \gcd(a, b) $ï¼Œè€Œ $ x_1 $ å’Œ $ y_1 $ å³ä¸ºè´ç¥–ç­‰å¼ $ ax + by = \gcd(a, b) $ çš„æ•´æ•°è§£ã€‚

##### æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•çš„æ€æƒ³

- **é€’å½’å…³ç³»**ï¼šæ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•é€šè¿‡ä¸æ–­åœ°åˆ©ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•ä¸­çš„é€’å½’å…³ç³» $ \gcd(a, b) = \gcd(b, a \mod b) $ æ¥æ±‚è§£æœ€å¤§å…¬çº¦æ•°ï¼ŒåŒæ—¶è®°å½•æ¯ä¸€æ­¥çš„è¾…åŠ©ç³»æ•° $ x $ å’Œ $ y $ã€‚
- **åå‘æ¨å¯¼**ï¼šä»æ¬§å‡ é‡Œå¾—ç®—æ³•çš„åå‘æ¨å¯¼å‡ºå‘ï¼Œåˆ©ç”¨è¾…åŠ©ç³»æ•° $ x $ å’Œ $ y $ çš„é€’æ¨å…³ç³»ï¼Œå¯ä»¥åœ¨æ¯ä¸€æ­¥çš„è®¡ç®—ä¸­æ›´æ–°è¿™ä¸¤ä¸ªç³»æ•°ï¼Œæœ€ç»ˆå¾—åˆ°è´ç¥–ç­‰å¼çš„æ•´æ•°è§£ã€‚
- **æ¨¡é€†å…ƒæ±‚è§£**ï¼šæ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•ä¸­çš„ $ x $ å’Œ $ y $ çš„æ•´æ•°è§£ $ ax + by = \gcd(a, b) $ å¯ä»¥ç”¨äºæ±‚è§£æ¨¡é€†å…ƒé—®é¢˜ï¼Œå³ $ ax \equiv 1 \pmod{b} $ çš„è§£ä¸º $ x $ã€‚

æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•åœ¨å¯†ç å­¦ä¸­å¸¸ç”¨äºæ±‚è§£æ¨¡é€†å…ƒã€è§£å†³çº¿æ€§åŒä½™æ–¹ç¨‹ã€è®¡ç®—æœ€å¤§å…¬çº¦æ•°ç­‰é—®é¢˜ï¼Œå…·æœ‰è¾ƒé«˜çš„å®ç”¨ä»·å€¼å’Œå¹¿æ³›çš„åº”ç”¨åœºæ™¯ã€‚

åœ¨è¿™é‡Œé‡‡ç”¨æ‰©å±•çš„æ¬§å‡ é‡Œå¾—ç®—æ³•è¿›è¡Œå¿«é€Ÿæ±‚è§£ã€‚å…¶ä»£ç å¦‚ä¸‹ï¼š

```c++
uint64_t RSA::ModInv(uint64_t a, uint64_t m) {
    // Use the extended Euclidean algorithm
    /*
     * The extended Euclidean algorithm finds the modular multiplicative inverse of a modulo m.
     * If a and m are coprime, then a^(-1) mod m exists and the function returns the modular multiplicative inverse of a modulo m.
     * If a and m are not coprime, then a^(-1) mod m does not exist and the function returns 0.
     */

    assert(a < m); // Ensure a < m

    // NOTE: Use signed integer for that the result may be negative; use 128-bit integer to avoid overflow
    int128_t r0 = m, r = a; // Remainder sequence
    int128_t q = -1; // Quotient sequence
    int128_t s0 = 1, s = 0;
    int128_t t0 = 0, t = 1;

    while (r0 % r) { // If the remainder is not 0, continue the loop
        int128_t tmp = r0;
        r0 = r;
        r = tmp % r0;

        q = tmp / r0;

        tmp = s0;
        s0 = s;
        s = tmp - s0 * q;

        tmp = t0;
        t0 = t;
        t = tmp - t0 * q;
    }

    if (r == 1) { // If a and m are coprime, then a^(-1) mod m exists
        // Ensure the result is positive
        if (s < 0)
            s += a;
        if (t < 0)
            t += m;
        return t;
    }

    return 0; // a and m are not coprime, then a^(-1) mod m does not exist
}
```

âš ï¸ éœ€è¦æ³¨æ„çš„æ˜¯ï¼šæ‰©å±•çš„æ¬§å‡ é‡Œå¾—ç®—æ³•åŒæ ·åŒ…å«åŸæœ‰çš„æ¬§å‡ é‡Œå¾—æ±‚**æœ€å¤§å…¬çº¦æ•°**ç®—æ³•çš„æ­¥éª¤ï¼Œè€Œå½“äºŒè€…çš„æœ€å¤§å…¬çº¦æ•°ä¸º $1$ æ—¶ï¼ˆå³äºŒè€…äº’ç´ æ—¶ï¼‰ï¼Œä¹˜æ³•é€†å…ƒ**å­˜åœ¨**ï¼Œå¹¶å¯ä»¥æ ¹æ®æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•æ±‚å‡ºï¼›è€Œå½“äºŒè€…çš„æœ€å¤§å…¬çº¦æ•°ä¸ä¸º $1$ æ—¶ï¼ˆå³äºŒè€…ä¸äº’ç´ æ—¶ï¼‰ï¼Œä¹˜æ³•é€†å…ƒ**ä¸å­˜åœ¨**ï¼Œåœ¨ä»£ç ä¸­è®¾ç½®è¯¥ç§æƒ…å†µçš„å‡½æ•°è¿”å›å€¼ä¸º $0$ ã€‚

#### ç´ æ€§æ£€æµ‹

**Miller-Rabinç´ æ€§æ£€æµ‹ç®—æ³•**æ˜¯ä¸€ç§ç”¨äºç¡®å®šä¸€ä¸ªæ•°æ˜¯å¦ä¸ºç´ æ•°çš„æ¦‚ç‡æ€§ç®—æ³•ã€‚å®ƒåŸºäº**è´¹é©¬å°å®šç†**å’Œ**äºŒæ¬¡æ¢æµ‹åŸç†**ï¼Œå…·æœ‰è¾ƒé«˜çš„æ•ˆç‡å’Œå¯é æ€§ï¼Œç‰¹åˆ«é€‚ç”¨äºå¤§æ•°çš„ç´ æ€§æ£€æµ‹ã€‚

##### Miller-Rabinç´ æ€§æ£€æµ‹ç®—æ³•çš„æ­¥éª¤

1. **é€‰æ‹©å¾…æ£€æµ‹çš„æ•° $ n $**ï¼šé€‰æ‹©ä¸€ä¸ªå¤§äº2çš„å¥‡æ•° $ n $ï¼Œä½œä¸ºå¾…æ£€æµ‹çš„æ•°ã€‚
2. **ç¡®å®š $ n-1 $ çš„å› å¼åˆ†è§£ $ n-1 = 2^s \times d $**ï¼šå°† $ n-1 $ è¿›è¡Œå› å¼åˆ†è§£ï¼Œå…¶ä¸­ $ s $ æ˜¯éè´Ÿæ•´æ•°ï¼Œ $ d $ æ˜¯å¥‡æ•°ã€‚
3. **é€‰æ‹©éšæœºæ•´æ•° $ a $**ï¼šé€‰æ‹©ä¸€ä¸ªä»‹äº 2 å’Œ $ n-2 $ ä¹‹é—´çš„éšæœºæ•´æ•° $ a $ã€‚
4. **è®¡ç®— $ a^d \mod{n} $**ï¼šè®¡ç®— $ a^d \mod{n} $ çš„å€¼ã€‚
5. **è¿›è¡ŒäºŒæ¬¡æ¢æµ‹**ï¼šè‹¥ $ a^d \mod{n} = 1 $ æˆ– $ a^d \mod{n} = n-1 $ï¼Œåˆ™ $ n $ å¯èƒ½æ˜¯ç´ æ•°ï¼Œè¿›è¡Œä¸‹ä¸€è½®æ£€æµ‹ã€‚å¦åˆ™ï¼Œç»§ç»­è¿›è¡Œä¸‹ä¸€æ­¥ã€‚
6. **é‡å¤äºŒæ¬¡æ¢æµ‹ $ s-1 $ æ¬¡**ï¼šå¯¹ $ a^{2^r \times d} \mod{n} $ è¿›è¡Œ $ s-1 $ æ¬¡äºŒæ¬¡æ¢æµ‹ï¼Œå…¶ä¸­ $ r $ ä» 1 åˆ° $ s-1 $ã€‚
7. **åˆ¤æ–­ $ n $ çš„ç´ æ€§**ï¼šè‹¥æ‰€æœ‰äºŒæ¬¡æ¢æµ‹éƒ½æ»¡è¶³ $ a^{2^r \times d} \mod{n} \neq n-1 $ï¼Œåˆ™ $ n $ ä¸ºåˆæ•°ï¼›å¦åˆ™ï¼Œ $ n $ å¯èƒ½ä¸ºç´ æ•°ã€‚

##### Miller-Rabinç´ æ€§æ£€æµ‹ç®—æ³•çš„æ€æƒ³

- **äºŒæ¬¡æ¢æµ‹åŸç†**ï¼šMiller-Rabinç´ æ€§æ£€æµ‹ç®—æ³•åŸºäºäºŒæ¬¡æ¢æµ‹åŸç†ï¼Œé€šè¿‡å¤šæ¬¡äºŒæ¬¡æ¢æµ‹ $ a^{2^r \times d} \mod{n} $ çš„å€¼æ¥åˆ¤æ–­ $ n $ æ˜¯å¦ä¸ºç´ æ•°ã€‚è‹¥å­˜åœ¨ä¸€ä¸ª $ a $ ä½¿å¾— $ a^d \mod{n} \neq 1 $ ä¸” $ a^{2^r \times d} \mod{n} \neq n-1 $ï¼Œåˆ™ $ n $ ä¸ºåˆæ•°ï¼›å¦åˆ™ï¼Œ $ n $ å¯èƒ½ä¸ºç´ æ•°ã€‚
- **è´¹é©¬å°å®šç†**ï¼šMiller-Rabinç´ æ€§æ£€æµ‹ç®—æ³•çš„æ ¸å¿ƒæ€æƒ³ä¹‹ä¸€æ˜¯åˆ©ç”¨è´¹é©¬å°å®šç† $ a^{p-1} \equiv 1 \pmod{p} $ï¼Œå…¶ä¸­ $ p $ æ˜¯ç´ æ•°ï¼Œæ¥è¿›è¡Œåˆæ­¥åˆ¤æ–­ã€‚å¦‚æœ $ n $ é€šè¿‡äº†å¤šæ¬¡äºŒæ¬¡æ¢æµ‹ï¼Œè¯´æ˜å®ƒä¸å¤§å¯èƒ½æ˜¯åˆæ•°ã€‚
- **æ¦‚ç‡æ€§ç®—æ³•**ï¼šéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒMiller-Rabinç´ æ€§æ£€æµ‹ç®—æ³•æ˜¯ä¸€ç§**æ¦‚ç‡æ€§ç®—æ³•**ï¼Œå…¶ç»“æœæ˜¯æœ‰ä¸€å®šæ¦‚ç‡çš„æ­£ç¡®æ€§ã€‚å› æ­¤ï¼Œåœ¨å®é™…åº”ç”¨ä¸­é€šå¸¸ä¼šè¿›è¡Œå¤šè½®æ£€æµ‹æ¥å¢åŠ å‡†ç¡®æ€§ã€‚

Miller-Rabinç´ æ€§æ£€æµ‹ç®—æ³•åœ¨å®é™…åº”ç”¨ä¸­è¢«å¹¿æ³›ä½¿ç”¨ï¼Œç‰¹åˆ«æ˜¯åœ¨å¯†ç å­¦å’Œæ•°å­—ç®—æ³•ä¸­ï¼Œç”¨äºåˆ¤æ–­å¤§æ•°çš„ç´ æ€§ã€‚è™½ç„¶æ˜¯æ¦‚ç‡æ€§ç®—æ³•ï¼Œä½†å…¶å‡†ç¡®æ€§å’Œæ•ˆç‡å¾—åˆ°äº†å¹¿æ³›è®¤å¯ã€‚

é‡‡ç”¨ Miller-Rabin ç®—æ³•è¿›è¡Œç´ æ€§æ£€æµ‹ã€‚

```c++
bool RSA::MillerRabin(uint64_t n, int round) {
    if (n == 2) return true;
    if (n < 2 || (n & 1) == 0) return false;

    // Write n as 2^k * m + 1
    uint64_t m = n - 1;
    uint64_t k = 0;
    while ((m & 1) == 0) {
        m >>= 1;
        k++;
    }

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<uint64_t> dis(2, n - 1);

    while (round--) { // Loop `round` times
        uint64_t a = dis(gen); // random init: [2, n-1]
        uint64_t b = ModExp(a, m, n);
        if (b == 1 || b == n - 1) continue;

        for (int i = 0; i < k; i++) {
            b = ModExp(b, 2, n);
            if ((b == n - 1) && (i < k - 1)) {
                b = 1;
                break;
            }
            if (b == 1) return false;
        }

        if (b != 1) return false; // Failed Fermat test
    }
    return true;
}
```

æ³¨æ„åˆ°è¿™æ˜¯ä¸€ä¸ª**æ¦‚ç‡æ€§ç®—æ³•**ï¼Œå› æ­¤éœ€è¦å¤šæ¬¡é‡å¤ä»¥ä¿è¯å‡ºé”™çš„æ¦‚ç‡å¤„åœ¨å¯æ¥å—çš„æå°çš„èŒƒå›´å†…ã€‚

### RSAå¯†é’¥ç”Ÿæˆ

```c++
bool RSA::GenerateKey() {
    // Generate prime numbers p and q
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<uint64_t> dis(0x20000000, 0xFFFFFFFF); // [2^29, 2^32-1]

    const int MAX_ROUND = 50;
    do {
        p = dis(gen);
    } while (!MillerRabin(p, MAX_ROUND));

    do {
        q = dis(gen);
    } while (!MillerRabin(q, MAX_ROUND));

    n = p * q;
    phi = (p - 1) * (q - 1);

    // Generate public key e
    /*
     * The public key e must be coprime with phi(n) and 1 < e < phi(n).
     * Because phi(n) is even, e is odd.
     * The public key e is commonly set to 65537 (2^16 + 1) because it is prime and has a short binary representation with only two bits set.
     */
    e = 65537; // Commonly used public key
    while (e < phi) {
        // if ((d = ModInv(e, phi))) { break;}

        /*
         * Below we use a more efficient way to find e
         * Here we let e:
         * 1. e is odd
         * 2. e is not a factor of phi
         * 3. e is prime
         * NOTE: This is a more strict condition than the original one
         * You can also use the original one to find e with a higher complexity by using the above code
         */
        if ((phi % e != 0) && (MillerRabin(e, MAX_ROUND))) {
            break;
        }
        e += 2; // Ensure e is odd
    }

    if (e >= phi) {
        // Failed to find e
        // Reset the key
        p = 0; q = 0; n = 0; phi = 0; e = 0; d = 0;
        return false;
    }

    d = ModInv(e, phi);
    return true;
}
```

>  âš ï¸ æ³¨æ„
>
> åœ¨RSAçš„å¯†é’¥ç”Ÿæˆæ—¶ï¼Œé‡‡ç”¨å¸¸ç”¨çš„65537ä½œä¸ºeçš„åˆå§‹å€¼ï¼Œå¹¶ä»¥æ­¤ä¸ºåŸºç¡€ç”Ÿæˆç¬¦åˆè¦æ±‚çš„eã€‚
>
> è¿™é‡Œé‡‡ç”¨äº†ä¸€ç§æ›´ä¸ºæœ‰æ•ˆçš„é€‰å–eçš„æ–¹å¼ï¼š
>
> 1. eä¸ºå¥‡æ•°
> 2. eä¸æ˜¯ $\varphi(n)$ çš„å› å­
> 3. eæ˜¯ç´ æ•°
>
> éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸€è¦æ±‚æ¯”æ­£å¸¸eçš„è¦æ±‚æ›´åŠ ä¸¥æ ¼ã€‚
>
> è¯¥ä»£ç æ³¨é‡Šçš„ä¸Šæ–¹ç»™å‡ºäº†å¸¸è§„çš„eçš„é€‰å–æ–¹æ³•ã€‚

### RSAåŠ å¯†ä¸è§£å¯†

æ ¹æ®å‰é¢çš„ä»‹ç»ï¼ŒRSAçš„åŠ å¯†ä¸è§£å¯†è¿‡ç¨‹å…¶å®å°±æ˜¯æ‰§è¡Œä¸€æ¬¡æ¨¡å¹‚è¿ç®—ã€‚

```c++
uint64_t RSA::Encrypt(uint32_t plainText, uint64_t e, uint64_t n) {
    return ModExp((uint64_t)plainText, e, n);
}
```

```c++
uint32_t RSA::Decrypt(uint64_t cipherText) {
    return (uint32_t)ModExp(cipherText, d, n);
}
```

### å¯†é’¥å®‰å…¨äº¤æ¢

åˆ©ç”¨ RSA è¿›è¡Œ DES å¯†é’¥çš„å®‰å…¨äº¤æ¢ï¼Œç„¶ååŸºäº DES è¿›è¡ŒèŠå¤©å†…å®¹çš„åŠ å¯†ä¸è§£å¯†ã€‚

è¿™éƒ¨åˆ†çš„æµç¨‹å¦‚ä¸‹ï¼š

1. æœåŠ¡å™¨ç«¯ç”Ÿæˆ RSA å…¬é’¥ä¸ç§é’¥å¯¹
2. æœåŠ¡å™¨ç«¯å‘å®¢æˆ·ç«¯å‘é€ RSA å…¬é’¥ï¼ˆå¯åœ¨ä¸å®‰å…¨ä¿¡é“ï¼‰
3. å®¢æˆ·ç«¯ç”Ÿæˆ DES å¯†é’¥
4. å®¢æˆ·ç«¯æ¥å—æœåŠ¡å™¨ç«¯å‘é€çš„ RSA å…¬é’¥ï¼Œå¹¶ç”¨å…¶åŠ å¯† DES å¯†é’¥ï¼Œè€Œåå°†åŠ å¯†åçš„ DES å¯†é’¥å‘é€ç»™æœåŠ¡å™¨ç«¯
5. æœåŠ¡å™¨ç«¯æ¥å—åŠ å¯†çš„ DES å¯†é’¥ï¼Œç”¨è‡ªå·±çš„ RSA ç§é’¥è§£å¯†
6. âœ… æœåŠ¡å™¨ç«¯ä¸å®¢æˆ·ç«¯å®Œæˆå¯†é’¥çš„å®‰å…¨äº¤æ¢

#### æœåŠ¡å™¨ç«¯ Server

Serverçš„ä¸»è¦å·¥ä½œï¼š

1. ç”Ÿæˆ RSA å…¬é’¥ä¸ç§é’¥å¯¹ï¼ˆè¯¥è¿‡ç¨‹å¯èƒ½å¤±è´¥ï¼Œæœ¬å®éªŒä¸­è®¾ç½®é‡å¤ä¸‰æ¬¡ï¼Œä¸‰æ¬¡å‡å¤±è´¥åå³é€€å‡ºï¼Œä½†æ˜¯æ¦‚ç‡æä½ï¼‰
2. å‘å®¢æˆ·ç«¯å‘é€å…¬é’¥
3. æ¥å—å®¢æˆ·ç«¯å‘é€çš„åŠ å¯†åçš„ DES å¯†é’¥
4. ä½¿ç”¨ RSA ç§é’¥è§£å¯†
5. è®¾ç½® DES å¯†é’¥

```c++
/* ==================== Key Exchange Begin ==================== */
// Generate RSA Keys
const int N_RETRY = 3; // Number of retries for RSA key generation
for (int i = 0; i < N_RETRY; i++) {
    if (rsa.GenerateKey()) {
        std::cout << "RSA key generated successfully." << std::endl;
        break;
    }

    if (i == N_RETRY - 1) {
        std::cerr << "Error: Failed to generate RSA key." << std::endl;
        std::cerr << "Server Exiting..." << std::endl;
        return;
    } else {
        std::cerr << "Warning: Failed to generate RSA key. Retrying..." << std::endl;
    }
}

// Send public key and modulus
uint64_t e = rsa.GetPublicKey();
uint64_t n = rsa.GetModulus();
if (send(clientSocket, &e, sizeof(e), 0) < 0) {
    std::cerr << "Error: Failed to send public key." << std::endl;
    return;
}
if (send(clientSocket, &n, sizeof(n), 0) < 0) {
    std::cerr << "Error: Failed to send modulus." << std::endl;
    return;
}

// Receive DES key from client
uint64_t desKey_enc[8];
if (recv(clientSocket, desKey_enc, sizeof(desKey_enc), 0) < 0) {
    std::cerr << "Error: Failed to receive DES key." << std::endl;
    return;
}

// Decrypt DES key using RSA private key
uint8_t desKey[8];
for (int i = 0; i < 8; i++) {
    desKey[i] = rsa.Decrypt(desKey_enc[i]);
}

// Set DES key
des.SetKey((char*)desKey);

std::cout << "Key exchange completed." << std::endl;
/* ===================== Key Exchange End ===================== */
```

#### å®¢æˆ·ç«¯ Client

Clientçš„ä¸»è¦å·¥ä½œï¼š

1. ç”Ÿæˆ DES å¯†é’¥
2. æ¥å—æœåŠ¡å™¨å‘é€çš„ RSA å…¬é’¥
3. åˆ©ç”¨ RSA å…¬é’¥å¯¹ DES å¯†é’¥è¿›è¡ŒåŠ å¯†
4. å°†åŠ å¯†åçš„ DES å¯†é’¥å‘é€ç»™æœåŠ¡å™¨

```c++
/* ==================== Key Exchange Begin ==================== */
// Generate DES key
des.RandomGenKey();
uint8_t* desKey;
desKey = des.GetKey();

// Receive RSA public key and modulus from server
uint64_t e, n;
if (recv(clientSocket, &e, sizeof(e), 0) < 0) {
    std::cerr << "Error: Failed to receive public key." << std::endl;
    return;
}
if (recv(clientSocket, &n, sizeof(n), 0) < 0) {
    std::cerr << "Error: Failed to receive modulus." << std::endl;
    return;
}

// Encrypt DES key using RSA public key
uint64_t desKey_enc[8];
for (int i = 0; i < 8; i++) {
    desKey_enc[i] = RSA::Encrypt((uint32_t)desKey[i], e, n);
}
delete[] desKey; // Release memory

// Send DES key to server
if (send(clientSocket, desKey_enc, sizeof(desKey_enc), 0) < 0) {
    std::cerr << "Error: Failed to send DES key." << std::endl;
    return;
}

std::cout << "Key exchange completed." << std::endl;
/* ===================== Key Exchange End ===================== */
```

### DESåŠ å¯†é€šä¿¡

æœ¬éƒ¨åˆ†å†…å®¹ä¸ä¸Šæ¬¡å®éªŒåŸºæœ¬ç›¸åŒï¼Œè¿™é‡Œä¸åœ¨èµ˜è¿°ã€‚

ç›¸å…³çš„æ¥å£å¦‚ä¸‹ï¼š

```c++
#include <cstdint> // uint8_t
#include <random> // Generate random number

#define get_bit(x, i) (((x) >> (i)) & 0x01)

class DesOp {
private:
    uint8_t key[8]; // 64-bit key
    uint8_t subKeys[16][6]; // 16 48-bit subkeys
    static uint8_t IP[64]; // Initial Permutation
    static uint8_t IP_INV[64]; // Inverse Initial Permutation
    static uint8_t E[48]; // Expansion Permutation (E-Box)
    static uint8_t S[8][4][16]; // S-Boxes
    static uint8_t P[32]; // Permutation (P-Box)
    static uint8_t PC1[2][28]; // Permuted Choice 1
    static uint8_t LS[16]; // Left Shifts
    static uint8_t PC2[48]; // Permuted Choice 2
    void GenerateSubKeys();
    void F(uint8_t* R, uint8_t* subKey, uint8_t* result);
    void DES(uint8_t* plainText, uint8_t* cipherText, bool isEncrypt);

    // Useful functions
    static void Xor(uint8_t* a, uint8_t* b, int length);
    static void Copy(uint8_t* a, uint8_t* b, int length);
    static void ByteToBit(uint8_t* byte, uint8_t* bit, int length);
    static void BitToByte(uint8_t* bit, uint8_t* byte, int length);
public:
    DesOp();
    ~DesOp();
    void RandomGenKey(); // Generate a random key
    uint8_t* GetKey(); // Get key
    void SetKey(const char* key);
    void Encrypt(char* plainText, int plainTextLength, char*& cipherText, int& cipherTextLength);
    void Decrypt(char* cipherText, int cipherTextLength, char*& plainText, int& plainTextLength);
};
```

### TCPèŠå¤©

æœ¬éƒ¨åˆ†å†…å®¹ä¸ä¸Šæ¬¡å®éªŒåŸºæœ¬ç›¸åŒï¼ŒåŒºåˆ«åœ¨äºè¿™é‡Œå¢åŠ äº†å¯†é’¥ç”Ÿæˆï¼ˆRSAä¸DESï¼‰ä¸å¯†é’¥ï¼ˆDESï¼‰å®‰å…¨äº¤æ¢çš„è¿‡ç¨‹ã€‚è¿™é‡Œä¸åœ¨èµ˜è¿°ã€‚

ç›¸å…³çš„æ¥å£å¦‚ä¸‹ï¼š

```c++
#ifdef _WIN32
    #include <winsock2.h>
    #define close(s) closesocket(s)
    typedef SSIZE_T ssize_t;
    typedef int socklen_t;
#else
    #include <sys/socket.h> // socket
    #include <arpa/inet.h>
    #include <unistd.h>
#endif

#include <thread> // thread
#include <atomic> // atomic
#include "DesOp.h" // DES Operation
#include "RSA.h" // RSA

#define DEFAULT_SERVER_IP "127.0.0.1" // Default server IP
#define DEFAULT_SERVER_PORT 8888 // Default server port
#define MAX_MESSAGE_LENGTH 512 // Maximum message length
#define EXIT_COMMAND "exit" // Exit command

class Chat {
private:
    bool isServer; // Server flag
    int serverSocket; // Server socket
    int clientSocket; // Client socket
    const char* serverIp; // Server IP
    int serverPort; // Server port
    char message[MAX_MESSAGE_LENGTH]; // Message
    char buffer[MAX_MESSAGE_LENGTH]; // Buffer
    std::atomic<bool> isRunning; // Running flag
    std::atomic<bool> exited; // Exited flag
    std::thread receiveThread; // Receive message thread object
    DesOp des; // DES Operation
    RSA rsa; // RSA
    void Init(); // Initialize
    void Connect(); // Connect to server (Only for client)
    void Send(); // Send message
    void ReceiveThread(); // Receive message thread function
    void Close(); // Close

public:
    Chat(); // Constructor
    ~Chat(); // Destructor
    void RunServer(); // Run Server
    void RunClient(); // Run Client
};
```

### å…¶ä»–äº‹é¡¹

æœ¬å®éªŒä¸­ï¼Œå‡ºäº†å‰é¢çš„è¦æ±‚ä¹‹å¤–ï¼Œè¿˜å®ç°äº†ï¼š

- é‡‡ç”¨æ¡ä»¶ç¼–è¯‘å®ç°**å¤šå¹³å°**ï¼ˆMulti-Platformï¼‰
- é‡‡ç”¨äº† `CMake` æ„å»ºç³»ç»Ÿ
- æ”¯æŒ `exit` æ‰‹åŠ¨é€€å‡ºå‘½ä»¤
- åˆ©ç”¨åŸå­æ“ä½œå®ç°å¤šçº¿ç¨‹å¹¶å‘æ§åˆ¶ï¼ˆå¤šçº¿ç¨‹å®‰å…¨ï¼‰

## äº”ã€å®éªŒç»“æœ

æœ¬æ¬¡å®éªŒå¯ä»¥è·¨å¹³å°ã€‚

> âš ï¸ æ³¨æ„ï¼šæœ¬å®éªŒä¸­æ‰€æäº¤çš„ç¨‹åºä¸º Linux ä¸‹çš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚

### MacOSç³»ç»Ÿ

![image-20240421230100332](./README.assets/image-20240421230100332.png)

å¯ä»¥çœ‹åˆ°ï¼Œç¨‹åºèƒ½å¤Ÿæ­£ç¡®å®ç°ï¼š

1. åŸºäºRSAçš„DESå¯†é’¥å®‰å…¨äº¤æ¢
2. DESåŠ å¯†é€šä¿¡ï¼ˆä¸­æ–‡ã€è‹±æ–‡ã€å…¶ä»–å­—ç¬¦ã€emojiğŸ˜„ç­‰ï¼‰
3. æ‰‹åŠ¨ç¨‹åºé€€å‡º `exit`

å› æ­¤æœ¬æ¬¡å®éªŒéå¸¸æˆåŠŸï¼

### Linuxç³»ç»Ÿ

<img src="./README.assets/image-20240421233651991.png" alt="image-20240421233651991" style="zoom:67%;" />

![image-20240421233820880](./README.assets/image-20240421233820880.png)

### Windowsç³»ç»Ÿ

![image-20240422003343414](./README.assets/image-20240422003343414.png)

> âš ï¸ æ³¨æ„
>
> MSVCç¼–è¯‘å™¨ä¸æ”¯æŒ 128 ä½æ•´æ•°ï¼Œè¿™é‡Œç¬”è€…é‡‡ç”¨çš„æ˜¯MinGW-w64ã€‚

## å…­ã€æ€»ç»“ä¸æ„Ÿæ‚Ÿ

æœ¬æ¬¡å®éªŒï¼Œç¬”è€…å®ç°äº†åŸºäº RSA çš„ DES å¯†é’¥å®‰å…¨äº¤æ¢ï¼Œä»¥åŠ DES åŠ å¯†çš„ TCP é€šä¿¡èŠå¤©ï¼Œå®éªŒéå¸¸æˆåŠŸï¼

é€šè¿‡æœ¬æ¬¡å®éªŒï¼Œæˆ‘å¤ä¹ å›é¡¾äº†ä¸Šå­¦æœŸçš„å¯†ç å­¦ä¸è®¡ç®—æœºç½‘ç»œçš„ç›¸å…³çŸ¥è¯†ï¼ŒæˆåŠŸåœ°å°†è‡ªå·±çš„æ‰€å­¦åº”ç”¨åˆ°å®è·µå½“ä¸­å»ï¼Œä½“ä¼šåˆ°äº†â€œè¯»ä¸‡å·ä¹¦ï¼Œè¡Œä¸‡é‡Œè·¯â€ï¼Œåšäº‹éœ€è¦èº¬èº«å®è·µçš„é“ç†ã€‚

å¸Œæœ›ç»è¿‡è¿™å­¦æœŸçš„å­¦ä¹ ï¼Œæˆ‘èƒ½å¤Ÿåœ¨ç½‘ç»œå®‰å…¨çš„é“è·¯ä¸Šè¶Šèµ°è¶Šè¿œï¼
